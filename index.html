<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>SSE HTTP POST Client</title>
<style>
/* Design tokens */
:root {
  --bg: #f6f7fb;
  --card: #ffffff;
  --text: #0b1220;
  --muted: #6b7280;
  --border: #e5e7eb;
  --soft: #f3f4f6;
  --primary: #2563eb;
  --primary-600: #1d4ed8;
  --radius: 14px;
  --shadow: 0 8px 28px rgba(0,0,0,0.06);
}
@media (prefers-color-scheme: dark) {
  :root {
    --bg: #0b0f19;
    --card: #0f1525;
    --text: #e5e7eb;
    --muted: #9aa4b2;
    --border: #1f2937;
    --soft: #121a2b;
    --primary: #3b82f6;
    --primary-600: #2563eb;
    --shadow: 0 10px 30px rgba(0,0,0,0.35);
  }
}

/* Base layout */
* { box-sizing: border-box; }
html, body { height: 100%; }
body {
  margin: 0;
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Ubuntu, Cantarell, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
  background: var(--bg);
  color: var(--text);
}
.app {
  max-width: 960px;
  margin: 0 auto;
  height: 100vh; /* ensure internal scroll uses chat, not page */
  display: flex;
  flex-direction: column;
  gap: 14px;
  padding: 16px;
}
.brand {
  font-size: 14px;
  letter-spacing: 0.04em;
  color: var(--muted);
  text-transform: uppercase;
}

/* Cards */
.card {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
}

/* Settings */
#settings {
  padding: 16px;
  display: grid;
  gap: 12px;
  grid-template-columns: 1fr 1fr auto;
  grid-template-areas: "url token actions";
}
#url { grid-area: url; }
#token { grid-area: token; }
#settings .actions { grid-area: actions; display: flex; gap: 8px; align-items: center; justify-content: flex-end; }

#settings input {
  width: 100%;
  padding: 12px 14px;
  border: 1px solid var(--border);
  background: var(--soft);
  color: var(--text);
  border-radius: 12px;
  outline: none;
  transition: box-shadow .15s ease, border-color .15s ease, background .15s ease;
}
#settings input::placeholder { color: var(--muted); }
#settings input:focus {
  border-color: var(--primary);
  box-shadow: 0 0 0 3px color-mix(in oklab, var(--primary) 20%, transparent);
  background: transparent;
}

/* Chat */
#chat {
  flex: 1 1 0%;
  overflow-y: auto;
  padding: 18px;
  scroll-behavior: smooth;
  min-height: 0; /* allow flex item to shrink and enable overflow */
}
.message { margin: 12px 0; display: flex; }
.message.user { justify-content: flex-end; }
.message.assistant { justify-content: flex-start; }
.message .bubble {
  max-width: 78%;
  padding: 12px 14px;
  border-radius: 16px;
  border: 1px solid var(--border);
  background: var(--soft);
  box-shadow: 0 2px 10px rgba(0,0,0,0.04);
  line-height: 1.55;
  font-size: 14px;
  white-space: pre-wrap;
  overflow-wrap: anywhere; /* allow breaking long tokens/URLs */
  word-break: break-word;  /* fallback for older browsers */
}
.message.user .bubble {
  background: color-mix(in oklab, var(--primary) 12%, var(--card));
  border-color: color-mix(in oklab, var(--primary) 35%, var(--border));
}
.message.assistant .bubble {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}

/* Input area */
#input-area {
  display: flex;
  gap: 12px;
  align-items: flex-end;
  padding: 12px;
}
#input-area textarea {
  flex: 1;
  resize: vertical;
  min-height: 46px;
  max-height: 240px;
  padding: 12px 14px;
  border: 1px solid var(--border);
  background: var(--soft);
  color: var(--text);
  border-radius: 12px;
  outline: none;
  transition: box-shadow .15s ease, border-color .15s ease, background .15s ease;
}
#input-area textarea:focus {
  border-color: var(--primary);
  box-shadow: 0 0 0 3px color-mix(in oklab, var(--primary) 20%, transparent);
  background: transparent;
}
#input-area button {
  padding: 12px 18px;
  border-radius: 12px;
  border: 1px solid color-mix(in oklab, var(--primary) 40%, var(--border));
  background: linear-gradient(180deg, var(--primary), var(--primary-600));
  color: white;
  font-weight: 600;
  cursor: pointer;
  transition: transform .06s ease, filter .15s ease, box-shadow .15s ease;
  box-shadow: 0 6px 16px color-mix(in oklab, var(--primary) 28%, transparent);
}
#input-area button:hover { filter: brightness(1.05); }
#input-area button:active { transform: translateY(1px); }

/* Ghost buttons for settings actions */
.ghost-btn {
  padding: 10px 12px;
  border-radius: 10px;
  border: 1px solid var(--border);
  background: transparent;
  color: var(--text);
  cursor: pointer;
}
.ghost-btn:hover { background: var(--soft); }

/* Responsive */
@media (max-width: 720px) {
  #settings { grid-template-columns: 1fr; grid-template-areas: "url" "token"; }
  .message .bubble { max-width: 88%; }
}
/* Scrollbar polish */
#chat::-webkit-scrollbar { width: 10px; }
#chat::-webkit-scrollbar-thumb { background: var(--border); border-radius: 8px; }
</style>
</head>
<body>
<div class="app">
  <div class="brand">SSE HTTP POST Client</div>
  <div id="settings" class="card">
  <input id="url" placeholder="Request URL" />
  <input id="token" placeholder="Token (optional)" />
  <div class="actions">
    <input id="config-file" type="file" accept="application/json" style="display:none" />
    <button id="import-config" class="ghost-btn" title="Import config.json">Import</button>
    <button id="export-config" class="ghost-btn" title="Export config.json">Export</button>
  </div>
  </div>
  <div id="chat" class="card"></div>
  <div id="input-area" class="card">
  <textarea id="prompt" rows="2" placeholder="Enter message..."></textarea>
  <button id="send">Send</button>
  </div>
</div>
<script>
const chat = document.getElementById('chat');
const sendBtn = document.getElementById('send');
const urlEl = document.getElementById('url');
const tokenEl = document.getElementById('token');
const importBtn = document.getElementById('import-config');
const exportBtn = document.getElementById('export-config');
const configFileEl = document.getElementById('config-file');
const CONFIG_KEY = 'sse_client_config_v1';

// Config persistence helpers
function saveConfigToLocal() {
  try {
    const cfg = { url: urlEl.value || '', token: tokenEl.value || '' };
    localStorage.setItem(CONFIG_KEY, JSON.stringify(cfg));
  } catch {}
}
function loadConfigFromLocal() {
  try {
    const raw = localStorage.getItem(CONFIG_KEY);
    if (!raw) return null;
    return JSON.parse(raw);
  } catch { return null; }
}
async function loadConfigFromFileNearby() {
  // Attempt to fetch ./sse-client.config.json if hosted via http(s). Ignore errors.
  try {
    const res = await fetch('./sse-client.config.json', { cache: 'no-store' });
    if (!res.ok) return null;
    const cfg = await res.json();
    return cfg;
  } catch { return null; }
}
function hydrateConfig(cfg) {
  if (!cfg) return;
  if (typeof cfg.url === 'string') urlEl.value = cfg.url;
  if (typeof cfg.token === 'string') tokenEl.value = cfg.token;
}

// Initialize config: localStorage first, then optional file override
(async function initConfig(){
  hydrateConfig(loadConfigFromLocal());
  const fileCfg = await loadConfigFromFileNearby();
  if (fileCfg) {
    hydrateConfig(fileCfg);
    saveConfigToLocal();
  }
})();

// Persist on change
urlEl.addEventListener('input', saveConfigToLocal);
tokenEl.addEventListener('input', saveConfigToLocal);

// Export / Import
exportBtn.addEventListener('click', () => {
  const data = { url: urlEl.value || '', token: tokenEl.value || '' };
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'sse-client.config.json';
  document.body.appendChild(a);
  a.click();
  URL.revokeObjectURL(a.href);
  a.remove();
});
importBtn.addEventListener('click', () => configFileEl.click());
configFileEl.addEventListener('change', async () => {
  const file = configFileEl.files && configFileEl.files[0];
  if (!file) return;
  try {
    const text = await file.text();
    const cfg = JSON.parse(text);
    hydrateConfig(cfg);
    saveConfigToLocal();
  } catch {}
  configFileEl.value = '';
});
// Ensure immediate scroll to bottom, bypassing smooth behavior during streaming
function scrollToBottomInstant() {
  const prev = chat.style.scrollBehavior;
  chat.style.scrollBehavior = 'auto';
  chat.scrollTop = chat.scrollHeight;
  // restore previous behavior (may be empty string)
  chat.style.scrollBehavior = prev;
}
// Wait one frame so layout updates before scrolling
function nextFrame() {
  return new Promise(resolve => requestAnimationFrame(() => resolve()));
}
// Scroll only the chat container to bottom (do not scroll the page)
function scrollToMessage(el) {
  const prev = chat.style.scrollBehavior;
  chat.style.scrollBehavior = 'auto';
  chat.scrollTop = chat.scrollHeight;
  chat.style.scrollBehavior = prev;
}
sendBtn.addEventListener('click', async () => {
   const url = document.getElementById('url').value.trim();
   const token = document.getElementById('token').value.trim();
   const prompt = document.getElementById('prompt').value;
   if(!url) return alert('URL required');
   addMessage(prompt, 'user');
   document.getElementById('prompt').value = '';
   saveConfigToLocal();
   const body = prompt; // use message as raw request body
   const msgEl = addMessage('', 'assistant');
   const contentEl = msgEl.querySelector('.bubble');
   try {
     const resp = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...(token ? {'Authorization': 'Bearer ' + token} : {})
        },
        body
     });
     if(!resp.body) {
        contentEl.textContent = await resp.text();
        scrollToMessage(msgEl);
        return;
     }
     const reader = resp.body.getReader();
     const decoder = new TextDecoder();
     while(true) {
       const {value, done} = await reader.read();
       if(done) break;
       const chunk = decoder.decode(value, {stream: true});
       // Append raw chunk without any processing
       contentEl.textContent += chunk;
       await nextFrame();
       scrollToMessage(msgEl);
     }
     // flush any remaining decoder buffer and do a final scroll
     const tail = decoder.decode();
     if (tail) contentEl.textContent += tail;
     await nextFrame();
     scrollToMessage(msgEl);
   } catch(err) {
     contentEl.textContent = err.message;
     chat.scrollTop = chat.scrollHeight;
   }
});
function addMessage(text, role){
  const wrapper = document.createElement('div');
  wrapper.className = 'message ' + role;
  const bubble = document.createElement('div');
  bubble.className = 'bubble';
  // Set raw text; no formatting/processing
  bubble.textContent = text || '';
  wrapper.appendChild(bubble);
  chat.appendChild(wrapper);
  // ensure scroll after DOM paints
  requestAnimationFrame(() => scrollToMessage(wrapper));
  return wrapper;
}
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>SSE HTTP POST Client</title>
<style>
/* Design tokens */
:root {
  --bg: #f6f7fb;
  --card: #ffffff;
  --text: #0b1220;
  --muted: #6b7280;
  --border: #e5e7eb;
  --soft: #f3f4f6;
  --primary: #2563eb;
  --primary-600: #1d4ed8;
  --radius: 6px;
  --shadow: 0 2px 8px rgba(0,0,0,0.04);
}
@media (prefers-color-scheme: dark) {
  :root {
    --bg: #0b0f19;
    --card: #0f1525;
    --text: #e5e7eb;
    --muted: #9aa4b2;
    --border: #1f2937;
    --soft: #121a2b;
    --primary: #3b82f6;
    --primary-600: #2563eb;
    --shadow: 0 6px 20px rgba(0,0,0,0.28);
  }
}

/* Base layout */
* { box-sizing: border-box; }
html, body { height: 100%; }
body {
  margin: 0;
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Ubuntu, Cantarell, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
  background: var(--bg);
  color: var(--text);
}
.app {
  max-width: 960px;
  margin: 0 auto;
  height: 100vh; /* ensure internal scroll uses chat, not page */
  display: flex;
  flex-direction: column;
  gap: 10px;
  padding: 14px;
}
.brand {
  font-size: 14px;
  letter-spacing: 0.02em;
  color: var(--muted);
  text-transform: none;
}

/* Cards */
.card {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
}

/* Settings */
#settings {
  padding: 12px;
  display: grid;
  gap: 10px;
  grid-template-columns: 1fr 1fr auto;
  grid-template-areas: "url token actions";
}
#url { grid-area: url; }
#token { grid-area: token; }
#settings .actions { grid-area: actions; display: flex; gap: 8px; align-items: center; justify-content: flex-end; }

#settings input {
  width: 100%;
  padding: 10px 12px;
  border: 1px solid var(--border);
  background: var(--soft);
  color: var(--text);
  border-radius: 6px;
  outline: none;
  transition: box-shadow .12s ease, border-color .12s ease, background .12s ease;
}
#settings input::placeholder { color: var(--muted); }
#settings input:focus {
  border-color: var(--primary);
  box-shadow: 0 0 0 2px color-mix(in oklab, var(--primary) 18%, transparent);
  background: transparent;
}

/* Chat */
#chat {
  flex: 1 1 0%;
  overflow-y: auto;
  padding: 14px;
  scroll-behavior: smooth;
  min-height: 0; /* allow flex item to shrink and enable overflow */
}
.message { margin: 12px 0; display: flex; }
.message.user { justify-content: flex-end; }
.message.assistant { justify-content: flex-start; }
.message .bubble {
  max-width: 76%;
  padding: 10px 12px;
  border-radius: 10px;
  border: 1px solid var(--border);
  background: var(--card);
  box-shadow: 0 2px 10px rgba(0,0,0,0.04);
  line-height: 1.55;
  font-size: 14px;
  white-space: pre-wrap;
  overflow-wrap: anywhere; /* allow breaking long tokens/URLs */
  word-break: break-word;  /* fallback for older browsers */
}
.message.user .bubble {
  background: color-mix(in oklab, var(--primary) 10%, var(--card));
  border-color: color-mix(in oklab, var(--primary) 28%, var(--border));
}
.message.assistant .bubble {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}

/* Input area */
#input-area {
  display: flex;
  gap: 10px;
  align-items: flex-end;
  padding: 10px;
}
#input-area .editor-toolbar {
  display: flex;
  align-items: center;
  gap: 8px;
}
#input-area .status {
  margin-left: auto;
  font-size: 12px;
}
#input-area .status.ok { color: #059669; }
#input-area .status.err { color: #dc2626; }
#input-area textarea {
  flex: 1;
  resize: vertical;
  min-height: 120px;
  max-height: 360px;
  padding: 10px 12px;
  border: 1px solid var(--border);
  background: var(--soft);
  color: var(--text);
  border-radius: 6px;
  outline: none;
  transition: box-shadow .12s ease, border-color .12s ease, background .12s ease;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 13px;
  line-height: 1.45;
}
#input-area textarea:focus {
  border-color: var(--primary);
  box-shadow: 0 0 0 2px color-mix(in oklab, var(--primary) 18%, transparent);
  background: transparent;
}
#input-area textarea.json-ok { border-color: #059669; box-shadow: 0 0 0 2px color-mix(in oklab, #059669 18%, transparent); }
#input-area textarea.json-err { border-color: #dc2626; box-shadow: 0 0 0 2px color-mix(in oklab, #dc2626 18%, transparent); }
#input-area button {
  padding: 10px 16px;
  border-radius: 6px;
  border: 1px solid color-mix(in oklab, var(--primary) 40%, var(--border));
  background: var(--primary);
  color: white;
  font-weight: 600;
  cursor: pointer;
  transition: transform .06s ease, filter .12s ease, box-shadow .12s ease;
  box-shadow: 0 2px 8px color-mix(in oklab, var(--primary) 18%, transparent);
}
#input-area #send {
  /* Distinct accent for Send button */
  background: #10b981; /* emerald-500 */
  border-color: color-mix(in oklab, #10b981 40%, var(--border));
  box-shadow: 0 2px 8px color-mix(in oklab, #10b981 24%, transparent);
}
#input-area button:hover { filter: brightness(1.05); }
#input-area button:active { transform: translateY(1px); }

/* Ghost buttons for settings actions */
.ghost-btn {
  padding: 8px 10px;
  border-radius: 6px;
  border: 1px solid var(--border);
  background: transparent;
  color: var(--text);
  cursor: pointer;
}
.ghost-btn:hover { background: var(--soft); }

/* Responsive */
@media (max-width: 720px) {
  #settings { grid-template-columns: 1fr; grid-template-areas: "url" "token"; }
  .message .bubble { max-width: 88%; }
}
/* Scrollbar polish */
#chat::-webkit-scrollbar { width: 10px; }
#chat::-webkit-scrollbar-thumb { background: var(--border); border-radius: 6px; }
</style>
</head>
<body>
<div class="app">
  <div class="brand">SSE HTTP POST Client</div>
  <div id="settings" class="card">
  <input id="url" placeholder="Request URL" />
  <input id="token" placeholder="Token (optional)" />
  <div class="actions">
    <input id="config-file" type="file" accept="application/json" style="display:none" />
    <button id="import-config" class="ghost-btn" title="Import config.json">Import</button>
    <button id="export-config" class="ghost-btn" title="Export config.json">Export</button>
  </div>
  </div>
  <div id="chat" class="card"></div>
  <div id="input-area" class="card">
    <div class="json-editor" style="flex:1; display:flex; flex-direction:column; gap:8px;">
      <div class="editor-toolbar">
        <button id="btn-format" class="ghost-btn" title="Format JSON">Format</button>
        <button id="btn-minify" class="ghost-btn" title="Minify JSON">Minify</button>
        <button id="send">Send</button>
        <span id="json-status" class="status muted">Waiting for JSONâ€¦</span>
      </div>
      <textarea id="prompt" rows="6" placeholder="Enter JSON body here..."></textarea>
    </div>
  </div>
</div>
<script>
const chat = document.getElementById('chat');
const sendBtn = document.getElementById('send');
const urlEl = document.getElementById('url');
const tokenEl = document.getElementById('token');
const promptEl = document.getElementById('prompt');
const statusEl = document.getElementById('json-status');
const formatBtn = document.getElementById('btn-format');
const minifyBtn = document.getElementById('btn-minify');
const importBtn = document.getElementById('import-config');
const exportBtn = document.getElementById('export-config');
const configFileEl = document.getElementById('config-file');
const CONFIG_KEY = 'sse_client_config_v1';

// Config persistence helpers
function saveConfigToLocal() {
  try {
    const cfg = { url: urlEl.value || '', token: tokenEl.value || '' };
    localStorage.setItem(CONFIG_KEY, JSON.stringify(cfg));
  } catch {}
}
function loadConfigFromLocal() {
  try {
    const raw = localStorage.getItem(CONFIG_KEY);
    if (!raw) return null;
    return JSON.parse(raw);
  } catch { return null; }
}
function hydrateConfig(cfg) {
  if (!cfg) return;
  if (typeof cfg.url === 'string') urlEl.value = cfg.url;
  if (typeof cfg.token === 'string') tokenEl.value = cfg.token;
}

// Initialize config: only from localStorage
(function initConfig(){
  hydrateConfig(loadConfigFromLocal());
})();

// Persist on change
urlEl.addEventListener('input', saveConfigToLocal);
tokenEl.addEventListener('input', saveConfigToLocal);

// JSON editor helpers
const LAST_JSON_KEY = 'sse_client_last_json_v1';
function setJsonStatus(ok, msg){
  if(statusEl){
    statusEl.textContent = msg || (ok ? 'Valid JSON' : '');
    statusEl.classList.toggle('ok', !!ok);
    statusEl.classList.toggle('err', !ok);
  }
  if(promptEl){
    promptEl.classList.toggle('json-ok', !!ok);
    promptEl.classList.toggle('json-err', !ok && promptEl.value.trim().length > 0);
  }
  if(sendBtn){ sendBtn.disabled = !ok; }
}
function positionToLineCol(text, pos){
  let line = 1, col = 1;
  for(let i=0;i<pos && i<text.length;i++){
    if(text[i] === '\n'){ line++; col = 1; } else { col++; }
  }
  return {line, col};
}
function validateJson(){
  if(!promptEl) return null;
  const v = promptEl.value.trim();
  if(!v){ setJsonStatus(false, ''); return null; }
  try {
    const obj = JSON.parse(v);
    setJsonStatus(true, 'Valid JSON');
    try { localStorage.setItem(LAST_JSON_KEY, JSON.stringify(obj)); } catch{}
    return obj;
  } catch(e){
    let msg = e && e.message ? String(e.message) : 'Invalid JSON';
    const m = msg.match(/position (\d+)/i);
    if(m){
      const pos = parseInt(m[1], 10) || 0;
      const {line, col} = positionToLineCol(promptEl.value, pos);
      msg += ` (line ${line}, col ${col})`;
    }
    setJsonStatus(false, msg);
    return null;
  }
}
// Load last valid JSON if available
try {
  const last = localStorage.getItem(LAST_JSON_KEY);
  if(last && promptEl){
    promptEl.value = JSON.stringify(JSON.parse(last), null, 2);
  }
} catch{}
// Initial validation state
validateJson();
if(promptEl){
  promptEl.addEventListener('input', validateJson);
  // Support Tab indent inside textarea
  promptEl.addEventListener('keydown', (e) => {
    if(e.key === 'Tab'){
      e.preventDefault();
      const start = promptEl.selectionStart;
      const end = promptEl.selectionEnd;
      const value = promptEl.value;
      const insert = '  ';
      promptEl.value = value.substring(0, start) + insert + value.substring(end);
      promptEl.selectionStart = promptEl.selectionEnd = start + insert.length;
    }
  });
}
// Pretty format
if(formatBtn){
  formatBtn.addEventListener('click', () => {
    const obj = validateJson();
    if(obj && promptEl){ promptEl.value = JSON.stringify(obj, null, 2); validateJson(); }
  });
}
// Minify
if(minifyBtn){
  minifyBtn.addEventListener('click', () => {
    const obj = validateJson();
    if(obj && promptEl){ promptEl.value = JSON.stringify(obj); validateJson(); }
  });
}
// (Template button removed)

// Export / Import
exportBtn.addEventListener('click', () => {
  const data = { url: urlEl.value || '', token: tokenEl.value || '' };
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'sse-client.config.json';
  document.body.appendChild(a);
  a.click();
  URL.revokeObjectURL(a.href);
  a.remove();
});
importBtn.addEventListener('click', () => configFileEl.click());
configFileEl.addEventListener('change', async () => {
  const file = configFileEl.files && configFileEl.files[0];
  if (!file) return;
  try {
    const text = await file.text();
    const cfg = JSON.parse(text);
    hydrateConfig(cfg);
    saveConfigToLocal();
  } catch {}
  configFileEl.value = '';
});
// (Removed Load Local button and related logic)
// Ensure immediate scroll to bottom, bypassing smooth behavior during streaming
function scrollToBottomInstant() {
  const prev = chat.style.scrollBehavior;
  chat.style.scrollBehavior = 'auto';
  chat.scrollTop = chat.scrollHeight;
  // restore previous behavior (may be empty string)
  chat.style.scrollBehavior = prev;
}
// Wait one frame so layout updates before scrolling
function nextFrame() {
  return new Promise(resolve => requestAnimationFrame(() => resolve()));
}
// Scroll only the chat container to bottom (do not scroll the page)
function scrollToMessage(el) {
  const prev = chat.style.scrollBehavior;
  chat.style.scrollBehavior = 'auto';
  chat.scrollTop = chat.scrollHeight;
  chat.style.scrollBehavior = prev;
}
sendBtn.addEventListener('click', async () => {
   const url = document.getElementById('url').value.trim();
   const token = document.getElementById('token').value.trim();
   const raw = document.getElementById('prompt').value;
   if(!url) return alert('URL required');
   const obj = validateJson();
   if(!obj) return alert('Please provide valid JSON.');
   const pretty = JSON.stringify(obj, null, 2);
   addMessage(pretty, 'user');
   // keep JSON in editor for iteration
   saveConfigToLocal();
   const body = JSON.stringify(obj); // normalized JSON
   const msgEl = addMessage('', 'assistant');
   const contentEl = msgEl.querySelector('.bubble');
   try {
     const resp = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...(token ? {'Authorization': 'Bearer ' + token} : {})
        },
        body
     });
     if(!resp.body) {
        contentEl.textContent = await resp.text();
        scrollToMessage(msgEl);
        return;
     }
     const reader = resp.body.getReader();
     const decoder = new TextDecoder();
     while(true) {
       const {value, done} = await reader.read();
       if(done) break;
       const chunk = decoder.decode(value, {stream: true});
       // Append raw chunk without any processing
       contentEl.textContent += chunk;
       await nextFrame();
       scrollToMessage(msgEl);
     }
     // flush any remaining decoder buffer and do a final scroll
     const tail = decoder.decode();
     if (tail) contentEl.textContent += tail;
     await nextFrame();
     scrollToMessage(msgEl);
   } catch(err) {
     contentEl.textContent = err.message;
     chat.scrollTop = chat.scrollHeight;
   }
});
function addMessage(text, role){
  const wrapper = document.createElement('div');
  wrapper.className = 'message ' + role;
  const bubble = document.createElement('div');
  bubble.className = 'bubble';
  // Set raw text; no formatting/processing
  bubble.textContent = text || '';
  wrapper.appendChild(bubble);
  chat.appendChild(wrapper);
  // ensure scroll after DOM paints
  requestAnimationFrame(() => scrollToMessage(wrapper));
  return wrapper;
}
</script>
</body>
</html>
